Конспект к краткому курсу 
GIT - Полный Курс Git и GitHub Для Начинающих [4 ЧАСА]
https://youtu.be/O00FTZDxD0o
---------------------------------------------------------------

GIT - распределённая система управления версиями
GitHub - сервис хостинга Git-репозиториев.

На каждом компьютере находится ПОЛНАЯ версия репозитория. С полной историей коммитов. Каждый репозиторий независим от других.

>
$
и прочие значки в начале строки в консоли - это Command line prompt, они могут быть разными в разных терминалах.

У приложений обычно бывают версии. Например, 2.39.1 - тут 2 - major version, 39 - minor version, 1 - patch

git config --list показывает все настройки гита, включая user.name и user.email, которые стоит указывать, чтобы было понятно, кто делал коммиты и как с ним связаться.

Основные команды в терминале:

cd ~ ............................Переход в корневую папку пользователя (C:\Users\sovun\)
mkdir my-project ................Создание новой папки (make directory)
cd my-project ...................Переход в папку (cd - change directory)
echo "Some text" > file.txt .....Создание файла file.txt с текстом "Some text"
ls ..............................Список файлов в папке
cat file.txt ....................Чтение файла
rm file.txt .....................Удаление файла
pwd .............................Path working directory - полный путь к текущей папке

Внутри приложения терминала запускается оболочка (shell). У каждой оболочки есть своя строка приветствия (command line prompt). 
При этом в одном и том же терминале можно запускать разные оболочки. С помощью оболочки мы можем взаимодействовать с ядром компьютера.
В Windows терминал и оболочка в нём называются одинаково - Power Shell.

git init ...........................Создание нового репозитория
Новый репозиторий можно создавать где угодно на компьютере. Для этого нужно сначала перйти в ту папку, где нужно создать репозиторий. Папка может быть не пустой.
После инициализации создаётся скрытая папка .git. Её можно увидеть, использовав следующие команды:

ls -la ..........................Отображение скрытых папок и файлов (Git Bash)
ls -Force .......................Отображение скрытых папок и файлов (PowerShell)
git branch ......................Показать название текущей ветки

Основнаяя ветка называется master (устаревшее название, не везде используется) или main (используется, например, на GitHub)

В папке .git хранятся все объекты, которые касаются данного репозитория.

Области Git:
Рабочая директория Working directory
Содержит видимые файлы и папки в проекте (ls). (Всё, что лежит вне .git)

Индекс Staging area
Сюда добавляются файлы до того, как мы хотим их сохранить. Т.е. там мы подготавливаем файлы для сохранения. Тут могут находиться как новые, так и старые, но изменённые файлы.
Посмотреть, чтот тут есть, можно при помощи команды git status. Если изменений нет - то ничего не будет показано.

Репозиторий Repository
Из индекса файлы сохраняются и записываются в репозиторий в папке .git Там же хранятся коммиты.
В нём есть изначальные папки info и pack. При создании коммитов в нём будут созданы подпапки. В них есть файлы с длинными уникальными названиями, созданные при помощи хэша. Каждый объект имеет уникальное название.

В репозитории разные версии одного и того же файла хранятся в абсолютно разных объектах под разными именами.

Раб.дир. ----git add----> Индекс ----git commit----> Репозиторий
    ↖------------------git checkout---------------------┘


git add file.txt ................Добавить файл в индекс (подготовить)
git add .    ....................Добавить все модифицированные и новые файлы в индекс (подготовить)
git commit ......................Сохранить файл в репозиторий
git checkout ....................Перейти к определённой версии проекта

git commit Сохраянет изменения. Создаёт новый коммит, т.е новый объект в папке objects, а коммит указывает на текущую версию проекта. Все файлы из индекса переносятся в репозиторий.
git checkout берёт файлы из репозиторий и перемещает их в рабочую директорию, т.е она полностью перезаписывается.

Статусы отслеживания файлов:
Untracked (неотслеживаемый) - только созданный файл, который не добавлен в индекс.
Staged (подготовленный) - добавленный в индекс.
Unmodified (немодифицированный) - файл в рабочей директории и в репозитории совпадают, т.е. файл не поменялся с последнего коммита.
Modified (модифицированный) - файл есть и в рабочей директории и в репозитории, но в неём есть какие-то изменения.

Типы объектов в git: 
Blob (файл) - для каждой версии файла создаётся отдельный объект blob
Tree (папка) - содержит ссылки на файлы и подпапки, находящиеся в ней.
Commit (коммит) - создаётся, когда мы сохраняем текущую версию проекта. Включает в себя данные об авторе.
Annotated Tag (аннотированный тег) - его можно создать в любой моент и вернуться к нему по имени.

Каждый объект в Git имеет уникальный id (SHA1 хэш). Он создаётся при помощи SHA1 хэш-функции. Хэш id на выходе имеет фиксированную длину - 40 шестнадцатиричных символов.
Название папки - это первые два символа хэша, а название файла - оставшиеся 38 символов.

Коммит - это указатель на дерево.
При создании коммита создаются объекты под каждую папку и под каждый файл + 1 объект типа коммит, который указывает (ссылается) на корневую папку (дерево).
У объекта коммита есть своё название (SHA1 хэш), внутри него есть:
- Имя и email автора
- Описание коммита
- Родительский(е) коммит(ы) (SHA1) - т.е. ссылки на один или несколько предыдущих коммитов (несколько их бывает, когда происходит слияние ветвей)
- Дерево (SHA1), а вернее ссылка на него

Самый первый коммит после создания проекта - это корневой коммит (root commit). Второй коммит будет ссылаться на первый (корневой) коммит, т.е первый коммит будет указан как родительский у второго.

В Git есть указатель, который называется HEAD. Он ссылается на определённый коммит. Именно этот коммит в данный момент отображается в рабочей директории. перемещая указатель HEAD, мы можем двигаться по истории проекта и менять отображаемые в рабочей директории файлы. Т.е. это указатель ту версию проекта, которая находится в рабочей директории.

Но вообще обычно HEAD ссылается на ветку, а уже сама ветка ссылается на определённый коммит (а он ссылается на дерево).
При создании нового коммита Git автоматически передвигает указатель ветки на последний коммит этой ветки. Соответственно, HEAD указывает на ту же ветку, но она указывает на новый коммит. И HEAD тогда ссылается на самый актуальный коммит.
Если же мы хотим переключиться на более старый коммит - HEAD будет ссылаться на коммит непосредственно, минуя ветку, т.к. она всегда указывает только на послежний коммит.

Объект с информацией по папке - это фактически просто текстовый файл со ссылками на его содержимое. если содержимое поменялось - то поменяются и ссылки, а значит, поменяется и объект. Т.е. вместе с изменением файла меняется и его родительская папка (и относящийся к ней объект).

...

Основные команды Git

git status ......................Отображает текущее состояние репозитория
git add <files> .................Подготовить файлы перед коммитом
git commit -m "<message>" .......Создание коммита с записью изменений в репозиторий
git log .........................Просмотр истории изменений (коммитов) до последнего коммита
git checkout <commit hash> ......Переход в определённую версию проекта по SHA1 хэшу коммита
git checkout <branch name> ......Переход в определённую версию проекта по названию ветки

При выполнении команды git commit Git создаст новый объект типа коммит, а вот объекты для соответствующих файлов и папок были созданы ранее, при добавлении файлов в индекс.

git cat-file -t <object hash> ...Тип объекта
git cat-file -p <object hash> ...Содержимое объекта

В целом состояние, когда мы переходим на старый коммит с помощью git chackout, называется detached HEAD. Находится в этом состоянии не рекомендуется, т.к. так HEAD указывает не на ветку, а на коммит напрямую. Но нам стоит всегда работать в рамках ветки. Но тем не менее в таком состоянии можно посмотреть на состояние коммита, а затем просто вернуться в какую-нибудь ветку.
Ещё, переключившись на старый коммит и выполнив git log, мы не увидим никаких коммитов, созданных позднее, потому что на момент создания того старого коммита их попросту ещё не существовало.

Если мы смотрим git log одной ветки - мы не увидим в нём коммиты из других веток. Мы увидим историю коммитов в этой ветке и старые коммиты из той ветки, от которой была создана эта (от корневого до того коммита, с которого началась текущая ветка).

git branch <branch name> ..........Создание новой ветки
git checkout -b <branch name> .....Создание новой ветки и мгновенное переключение в неё (т.е. git branch smth и git checkout smth)
git branch ........................Отображает список всех веток
git branch -m <new branch name> ...Переименование ТЕКУЩЕЙ ветки (в том числе можно переименовать master)
git branch -d <branch name> .......Удаление ветки по имени (но не текущую)

Перед удалением ветки из неё нужно выйти, т.е. переключиться в другую.

Слияние веток.
При слиянии веток создаётся новый merge комиит, у которого будут два родительских коммита из двух сливаемых веток. В этом новом коммите будет видна история обеих веток.

В ветке, которую влили в main, всё равно остаётся свой указательна её полседний коммит до слияния. Но зачастую после слияния ветка и указатель на неё уже не нужны, так что ветку можно удалять. При этом история коммитов всё равно сохранится - удаление ветки уже не удалит эти коммиты - они будут храниться в истории merge коммита.

git merge -m <message> <feature branch name> ...Слияние другой ветки в текущую ветку (feature branch) в текущую ветку (receiving branch) + сообщение

В VScode плюсик рядом с файлом добавит файл в индекс,  т.е. подготовит его. (Stage changes)



Удалённые репозитории
git push ..........................Загрузка локальных изменений в ветке в ветку удалённого репозитория
git pull ..........................Скачивание и применение изменений с удалённой ветки в локальную ветку

git clone <url> ...................Клонирование удалённого репозитория в локальный

При клонировании удалённого репозитория локально создаётся не только его копия, но и связь с оригинальным репозиторием.
Origin - имя удалённого репозитория по умолчанию.

git branch -a  ....................Отображает все ветки, включая те, которые находятся в удалённых репозиториях
git checkout <branch name>  .......Переход в любую ветку, в том числе в удалённом репозитории

git push и git pull работают в рамках одной ветки и синхронизируют лишь одну ветку.

git remote add origin <url> .......Подключение удалённого репозитория, где origin - это название удалённого репозитория (связи пока нет)
git push -u origin <branch> .......Загрузка изменений из локальной ветки в удалённую ветку с созданием связи между ними

Когда мы создаём связь между локальной и удалённой веткой, ветки могут иметь разные названия (но обычно оно всё же совпадает). После создания связи мы можем все дальнейшие загрузки изменений в ветку удалённого репозитория делать при помощи обычного git push.
и при наличии связи между локальной и удалённой веткой мы можем скачивать изменения при помощи git pull
Т.е порядок такой:
git remote add origin <url> -> git push -u origin <branch> -> git push/pull

git remote -v .....................Проверить настройку удаленного сервера
git fetch .........................Скачать изменения с удалённого репозитория, но не применять их локально
git branch -vv ....................Посмотреть, как именно локальная ветка связана с удалённой веткой

Если проект с репозиторием уже существуют локально - можно создать на GitHub репозиторий и потом следовать инструкциям из раздела …or push an existing repository from the command line